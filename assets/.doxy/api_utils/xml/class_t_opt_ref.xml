<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.15.0" xml:lang="en-US">
  <compounddef id="class_t_opt_ref" kind="class" language="C++" prot="public">
    <compoundname>TOptRef</compoundname>
    <includes refid="_t_opt_ref_8h" local="no">TOptRef.h</includes>
    <templateparamlist>
      <param>
        <type>typename T</type>
      </param>
    </templateparamlist>
    <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_t_opt_ref_1a32ed303aabc85e550ba58665a518837b" prot="private" static="no" mutable="no">
        <type>T *</type>
        <definition>T* TOptRef&lt; T &gt;::ptr</definition>
        <argsstring></argsstring>
        <name>ptr</name>
        <qualifiedname>TOptRef::ptr</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="21" column="3" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="21" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="class_t_opt_ref_1aa56016a1dd44de0bd878672b2b29f4aa" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type>FORCEINLINE</type>
        <definition>FORCEINLINE TOptRef&lt; T &gt;::TOptRef</definition>
        <argsstring>()</argsstring>
        <name>TOptRef</name>
        <qualifiedname>TOptRef::TOptRef</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="24" column="22" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="24" bodyend="27"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a9679ebcbb8e591c63032f9ec3effb5d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>FORCEINLINE</type>
        <definition>FORCEINLINE TOptRef&lt; T &gt;::TOptRef</definition>
        <argsstring>(T &amp;ref)</argsstring>
        <name>TOptRef</name>
        <qualifiedname>TOptRef::TOptRef</qualifiedname>
        <param>
          <type>T &amp;</type>
          <declname>ref</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="29" column="13" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="29" bodyend="32"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a0f74b71b5917a4c5e6bafcc95ef208d8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>FORCEINLINE</type>
        <definition>FORCEINLINE TOptRef&lt; T &gt;::TOptRef</definition>
        <argsstring>(T *ptr)</argsstring>
        <name>TOptRef</name>
        <qualifiedname>TOptRef::TOptRef</qualifiedname>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="35" column="13" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="35" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a156a170db9f169f01325ac3c6624e570" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>FORCEINLINE</type>
        <definition>FORCEINLINE TOptRef&lt; T &gt;::TOptRef</definition>
        <argsstring>(T &amp;&amp;rvalRef)</argsstring>
        <name>TOptRef</name>
        <qualifiedname>TOptRef::TOptRef</qualifiedname>
        <param>
          <type>T &amp;&amp;</type>
          <declname>rvalRef</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="41" column="13" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="41" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a84ffb13c3920c51197e9c2349f822aa9" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>FORCEINLINE bool</type>
        <definition>FORCEINLINE bool TOptRef&lt; T &gt;::IsPresent</definition>
        <argsstring>() const noexcept</argsstring>
        <name>IsPresent</name>
        <qualifiedname>TOptRef::IsPresent</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="48" column="18" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="48" bodyend="51"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a9b47ab26f114025b0fb381641f55861c" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>FORCEINLINE bool</type>
        <definition>FORCEINLINE bool TOptRef&lt; T &gt;::IsAbsent</definition>
        <argsstring>() const noexcept</argsstring>
        <name>IsAbsent</name>
        <qualifiedname>TOptRef::IsAbsent</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="53" column="18" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="53" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a3dc743843189e9871240666825f3d966" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>FORCEINLINE</type>
        <definition>FORCEINLINE TOptRef&lt; T &gt;::operator bool</definition>
        <argsstring>() const noexcept</argsstring>
        <name>operator bool</name>
        <qualifiedname>TOptRef::operator bool</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="58" column="13" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="58" bodyend="61"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1af4201f958c1d1e94dc7a66fd24187654" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>FORCEINLINE T &amp;</type>
        <definition>FORCEINLINE T &amp; TOptRef&lt; T &gt;::GetOrThrow</definition>
        <argsstring>() const</argsstring>
        <name>GetOrThrow</name>
        <qualifiedname>TOptRef::GetOrThrow</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the contained reference if present.</para>
<para>If absent, throws a <computeroutput>std::runtime_error</computeroutput> describing the error.</para>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>If the value is absent. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="73" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="73" bodyend="76"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ae7397f4e9d7068bf1c30b87cd5ccbccf" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>FORCEINLINE T &amp;</type>
        <definition>FORCEINLINE T &amp; TOptRef&lt; T &gt;::GetOrThrow</definition>
        <argsstring>(const std::string errorMessage) const</argsstring>
        <name>GetOrThrow</name>
        <qualifiedname>TOptRef::GetOrThrow</qualifiedname>
        <param>
          <type>const std::string</type>
          <declname>errorMessage</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the contained reference if present.</para>
<para>If absent, throws a <computeroutput>std::runtime_error</computeroutput> with the provided error message.</para>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::runtime_error</parametername>
</parameternamelist>
<parameterdescription>
<para>If the value is absent. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="85" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="85" bodyend="90"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a5f951fd9dbff9807f950b4ff89877590" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _ExceptionFactory</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; std::exception, _ExceptionFactory &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE T &amp;</type>
        <definition>FORCEINLINE T &amp; TOptRef&lt; T &gt;::GetOrThrow</definition>
        <argsstring>(const _ExceptionFactory exceptionFactory) const</argsstring>
        <name>GetOrThrow</name>
        <qualifiedname>TOptRef::GetOrThrow</qualifiedname>
        <param>
          <type>const _ExceptionFactory</type>
          <declname>exceptionFactory</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If the contained reference is present, returns it.</para>
<para>If absent, throws the exception created by the provided factory method.</para>
<para><parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::exception</parametername>
</parameternamelist>
<parameterdescription>
<para>If the value is absent. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="100" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="100" bodyend="105"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a4957f2b787751731a9fdc91c07efa495" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>FORCEINLINE T &amp;</type>
        <definition>FORCEINLINE T &amp; TOptRef&lt; T &gt;::GetOrDefault</definition>
        <argsstring>(T &amp;Default) const noexcept</argsstring>
        <name>GetOrDefault</name>
        <qualifiedname>TOptRef::GetOrDefault</qualifiedname>
        <param>
          <type>T &amp;</type>
          <declname>Default</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the stored reference if present, else returns Default. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="110" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="110" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a05a83aa61596f23adb68527a3a1658ab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _Computer</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; T &amp;, _Computer &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE T &amp;</type>
        <definition>FORCEINLINE T &amp; TOptRef&lt; T &gt;::GetOrCompute</definition>
        <argsstring>(_Computer computer)</argsstring>
        <name>GetOrCompute</name>
        <qualifiedname>TOptRef::GetOrCompute</qualifiedname>
        <param>
          <type>_Computer</type>
          <declname>computer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the stored reference if present, else executes the provided function and returns it. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>computer</parametername>
</parameternamelist>
<parameterdescription>
<para>A <computeroutput>T&amp; (void)</computeroutput> function or lambda </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="124" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="124" bodyend="130"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a27cd73704eb5ea88b4eec8a94c5d3199" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>FORCEINLINE T *</type>
        <definition>FORCEINLINE T * TOptRef&lt; T &gt;::GetPtrOrNull</definition>
        <argsstring>() const noexcept</argsstring>
        <name>GetPtrOrNull</name>
        <qualifiedname>TOptRef::GetPtrOrNull</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the stored reference as a pointer if present, else nullptr. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="135" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="135" bodyend="138"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ac8cee5d28098ca4fdcf4356b0a9442c2" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>FORCEINLINE T &amp;</type>
        <definition>FORCEINLINE T &amp; TOptRef&lt; T &gt;::GetUnchecked</definition>
        <argsstring>() const noexcept</argsstring>
        <name>GetUnchecked</name>
        <qualifiedname>TOptRef::GetUnchecked</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="140" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="140" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a7293eed17c4eb659701bb7f3136e09ce" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _Action</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_v&lt; _Action, const T &amp; &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref></type>
        <definition>FORCEINLINE TOptRef TOptRef&lt; T &gt;::IfPresent</definition>
        <argsstring>(_Action action) const</argsstring>
        <name>IfPresent</name>
        <qualifiedname>TOptRef::IfPresent</qualifiedname>
        <param>
          <type>_Action</type>
          <declname>action</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Execute the given lambda on the value if it is present, or does nothing if absent. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>The action to be performed in the form of a <computeroutput>void(const T&amp;)</computeroutput> function or lambda. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="154" column="21" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="154" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a1dae279b45fce7334dacee74d35327d6" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _Action</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_v&lt; _Action &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref></type>
        <definition>FORCEINLINE TOptRef TOptRef&lt; T &gt;::IfAbsent</definition>
        <argsstring>(_Action action) const</argsstring>
        <name>IfAbsent</name>
        <qualifiedname>TOptRef::IfAbsent</qualifiedname>
        <param>
          <type>_Action</type>
          <declname>action</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Executes the given action if the value is absent. Does nothing if the value is present. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>action</parametername>
</parameternamelist>
<parameterdescription>
<para>The action function/lambda to be performed. Signature = <computeroutput>void()</computeroutput> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="169" column="21" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="169" bodyend="176"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a9a861932ffbbd6377cde20b2aebe02e7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename _Mapper</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; TRetainedRef&lt; R &gt;, _Mapper, const T &amp; &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>&lt; R &gt;</type>
        <definition>FORCEINLINE TOptRef&lt; R &gt; TOptRef&lt; T &gt;::MapRef</definition>
        <argsstring>(_Mapper transformer) const</argsstring>
        <name>MapRef</name>
        <qualifiedname>TOptRef::MapRef</qualifiedname>
        <param>
          <type>_Mapper</type>
          <declname>transformer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Map the value to a new reference if present. Returns empty if absent.</para>
<para>Should <emphasis>not</emphasis> be used with a newly generated value, only to map this reference to one stored somewhere else. To contain a value, see <ref refid="" kindref="compound">.  R The new type.  transformer The transformation function or lambda. Signature = <computeroutput>R&amp;(const T&amp;)</computeroutput> or <computeroutput>TRetainedRef&lt;R&gt;(const T&amp;)</computeroutput>  The new optional reference. </ref></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="189" column="21" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="189" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1adf1099e338972547da0563ee5351740d" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename _Mapper</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>&lt; R &gt;, _Mapper, const T &amp; &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>&lt; R &gt;</type>
        <definition>FORCEINLINE TOptRef&lt; R &gt; TOptRef&lt; T &gt;::FlatMapRef</definition>
        <argsstring>(_Mapper transformer) const</argsstring>
        <name>FlatMapRef</name>
        <qualifiedname>TOptRef::FlatMapRef</qualifiedname>
        <param>
          <type>_Mapper</type>
          <declname>transformer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Map the value to the value of another optional reference if this value is present. Returns empty if absent.</para>
<para>Used to connect another function that returns an optional with this one, so you don&apos;t get <computeroutput><ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>&lt;<ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>&lt;Foo&gt;&gt;</computeroutput>. For example: <programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">Foo<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>TOptRef&lt;int&gt;<sp/>GetNumber();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">Foo<sp/>foo;</highlight></codeline>
<codeline><highlight class="normal">TOptRef&lt;Foo&gt;<sp/>bar<sp/>=<sp/>TOptRef(foo);</highlight></codeline>
<codeline><highlight class="normal">TOptRef&lt;int&gt;<sp/>baz<sp/>=<sp/>bar.<ref refid="class_t_opt_ref_1adf1099e338972547da0563ee5351740d" kindref="member">FlatMapRef</ref>&lt;</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&gt;([](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Foo&amp;<sp/>it)<sp/>-&gt;<sp/>TOptRef&lt;int&gt;<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>it.GetNumber();<sp/>});</highlight></codeline>
<codeline><highlight class="normal">assert(baz.IsPresent()<sp/>==<sp/>bar.IsPresent()<sp/>&amp;&amp;<sp/>foo.GetNumber().IsPresent());</highlight></codeline>
<codeline><highlight class="normal">assert(baz.<ref refid="class_t_opt_ref_1af4201f958c1d1e94dc7a66fd24187654" kindref="member">GetOrThrow</ref>()<sp/>==<sp/>bar.<ref refid="class_t_opt_ref_1af4201f958c1d1e94dc7a66fd24187654" kindref="member">GetOrThrow</ref>().GetNumber().GetOrThrow();</highlight></codeline>
</programlisting></para>
<para>Should <emphasis>not</emphasis> be used with a newly generated value, only to map this reference to one stored somewhere else. To contain a value, see <ref refid="" kindref="compound">.  R The new type.  transformer The transformation function or lambda. Signature = <computeroutput>R&amp;(const T&amp;)</computeroutput> or <computeroutput>TRetainedRef&lt;R&gt;(const T&amp;)</computeroutput>  The new optional reference. </ref></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="222" column="21" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="222" bodyend="228"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a4fbb624882f1c14c3af0e9e43bbcce79" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Predicate</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; bool, Predicate, const T &amp; &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref></type>
        <definition>FORCEINLINE TOptRef TOptRef&lt; T &gt;::Filter</definition>
        <argsstring>(Predicate shouldKeepValue) const</argsstring>
        <name>Filter</name>
        <qualifiedname>TOptRef::Filter</qualifiedname>
        <param>
          <type>Predicate</type>
          <declname>shouldKeepValue</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If this value is absent or the predicate returns false, return an empty optional. <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>A function or lambda that accepts <computeroutput>const T&amp;</computeroutput> and returns either <computeroutput>true</computeroutput> to return the current instance or <computeroutput>false</computeroutput> to return an empty <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>This instance if <computeroutput>shouldKeepValue</computeroutput> returns true or an empty <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref> if <computeroutput>shouldKeepValue</computeroutput> returns false. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="236" column="21" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="236" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ac347e0a187b4f72ce6caa5408b6871a0" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename _Mapper</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; R, _Mapper, const T &amp; &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE TOptional&lt; R &gt;</type>
        <definition>FORCEINLINE TOptional&lt; R &gt; TOptRef&lt; T &gt;::MapOwned</definition>
        <argsstring>(_Mapper transformer) const</argsstring>
        <name>MapOwned</name>
        <qualifiedname>TOptRef::MapOwned</qualifiedname>
        <param>
          <type>_Mapper</type>
          <declname>transformer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maps this reference to a new OWNED VALUE, which is STORED in the returned TOptional. Cannot return a reference. To return a reference, use <ref refid="" kindref="compound">.  R The new type.  transformer The function or lambda to generate the new value. Signature = <computeroutput>R(const T&amp;)</computeroutput>  A struct containing the newly-generated value, or empty if this object&apos;s stored value is absent. </ref></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="252" column="23" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="252" bodyend="258"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ab5d28c77bb4de4208ce243cf16bae19a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename _Mapper</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; TOptional&lt; R &gt;, _Mapper, const T &amp; &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE TOptional&lt; R &gt;</type>
        <definition>FORCEINLINE TOptional&lt; R &gt; TOptRef&lt; T &gt;::FlatMapOwned</definition>
        <argsstring>(_Mapper transformer) const</argsstring>
        <name>FlatMapOwned</name>
        <qualifiedname>TOptRef::FlatMapOwned</qualifiedname>
        <param>
          <type>_Mapper</type>
          <declname>transformer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Maps this reference to a new OWNED VALUE, which is STORED in the returned TOptional. Used to connect another function that returns an optional with this one so you don&apos;t get <computeroutput>TOptional&lt;TOptional&lt;Foo&gt;&gt;</computeroutput> Cannot return a reference. To return a reference, use <ref refid="" kindref="compound">.  R The new type.  transformer The function or lambda to generate the new value. Signature = <computeroutput>TOptional&lt;R&gt;(const T&amp;)</computeroutput>  A struct containing the newly-generated value, or empty if this object&apos;s stored value or the transformer&apos;s return value is absent. </ref></para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="269" column="23" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="269" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a35dadcbc4587d3df3e059a707ea8e3c7" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>FORCEINLINE TOptional&lt; T &gt;</type>
        <definition>FORCEINLINE TOptional&lt; T &gt; TOptRef&lt; T &gt;::ToOwned</definition>
        <argsstring>() const noexcept</argsstring>
        <name>ToOwned</name>
        <qualifiedname>TOptRef::ToOwned</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Copy the value stored in this reference into one stored in the returned struct. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="283" column="23" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="283" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a9ddaf93eda5e02d13024a0876b6dc0e8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _Computer</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; T, _Computer &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>FORCEINLINE T</type>
        <definition>FORCEINLINE T TOptRef&lt; T &gt;::ToOwnedOrCompute</definition>
        <argsstring>(_Computer computer)</argsstring>
        <name>ToOwnedOrCompute</name>
        <qualifiedname>TOptRef::ToOwnedOrCompute</qualifiedname>
        <param>
          <type>_Computer</type>
          <declname>computer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns a copy of the stored reference if it is present, or else executes the provided function if the reference is absent.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>computer</parametername>
</parameternamelist>
<parameterdescription>
<para>A function/lambda that accepts no arguments and returns an owned T instance. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="297" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="297" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a13d0b9643067b6b855ba093234f336d6" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>FORCEINLINE void</type>
        <definition>FORCEINLINE void TOptRef&lt; T &gt;::ToOwned</definition>
        <argsstring>(TOptional&lt; T &gt; &amp;Out) const noexcept</argsstring>
        <name>ToOwned</name>
        <qualifiedname>TOptRef::ToOwned</qualifiedname>
        <param>
          <type>TOptional&lt; T &gt; &amp;</type>
          <declname>Out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="305" column="18" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="305" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a1cec093d72cdeab5a61cbd4a001131c3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>FORCEINLINE T &amp;</type>
        <definition>FORCEINLINE T &amp; TOptRef&lt; T &gt;::operator*</definition>
        <argsstring>()</argsstring>
        <name>operator*</name>
        <qualifiedname>TOptRef::operator*</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="314" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="314" bodyend="317"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ae24825a8cf4a61cfcad11343b550fa5c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>FORCEINLINE T *</type>
        <definition>FORCEINLINE T * TOptRef&lt; T &gt;::operator-&gt;</definition>
        <argsstring>()</argsstring>
        <name>operator-&gt;</name>
        <qualifiedname>TOptRef::operator-&gt;</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="319" column="15" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="319" bodyend="322"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a24c011fa67975cab3524f60e3b9f7389" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>TOptRef&lt; T &gt;::TOptRef</definition>
        <argsstring>(const TOptRef &amp;other)</argsstring>
        <name>TOptRef</name>
        <qualifiedname>TOptRef::TOptRef</qualifiedname>
        <param>
          <type>const <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="325" column="1" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="325" bodyend="328"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1acd0ea3210a6422cfd8c3832e6fc8a85c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type></type>
        <definition>TOptRef&lt; T &gt;::TOptRef</definition>
        <argsstring>(TOptRef &amp;&amp;other) noexcept</argsstring>
        <name>TOptRef</name>
        <qualifiedname>TOptRef::TOptRef</qualifiedname>
        <param>
          <type><ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="330" column="1" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="330" bodyend="333"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ad597e62d4cfeafe177727166961cbfd1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref> &amp;</type>
        <definition>TOptRef &amp; TOptRef&lt; T &gt;::operator=</definition>
        <argsstring>(const TOptRef &amp;other)</argsstring>
        <name>operator=</name>
        <qualifiedname>TOptRef::operator=</qualifiedname>
        <param>
          <type>const <ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="335" column="9" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="335" bodyend="340"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1acaaac53a3ef39ec552657586474e614c" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type><ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref> &amp;</type>
        <definition>TOptRef &amp; TOptRef&lt; T &gt;::operator=</definition>
        <argsstring>(TOptRef &amp;&amp;other) noexcept</argsstring>
        <name>operator=</name>
        <qualifiedname>TOptRef::operator=</qualifiedname>
        <param>
          <type><ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref> &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="342" column="9" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="342" bodyend="347"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ac0e3a28440798946e9cbd78c490ffa69" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _Other</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_convertible_v&lt; T, _Other &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool TOptRef&lt; T &gt;::operator==</definition>
        <argsstring>(TOptRef&lt; _Other &gt; other) const noexcept</argsstring>
        <name>operator==</name>
        <qualifiedname>TOptRef::operator==</qualifiedname>
        <param>
          <type><ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>&lt; _Other &gt;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks object equality instead of pointer equality to keep the same contract as a standard reference. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="356" column="6" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="356" bodyend="361"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ac0e3a28440798946e9cbd78c490ffa69" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _Other</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_convertible_v&lt; T, _Other &gt;, int &gt;</type>
            <defval>0</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool TOptRef&lt; T &gt;::operator==</definition>
        <argsstring>(TOptRef&lt; _Other &gt; other) const noexcept</argsstring>
        <name>operator==</name>
        <qualifiedname>TOptRef::operator==</qualifiedname>
        <param>
          <type><ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>&lt; _Other &gt;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>If they hold non-convertible types, it&apos;s false. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="367" column="6" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="367" bodyend="370"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ab0042d7878115deabae1bea1c3044894" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool TOptRef&lt; T &gt;::operator==</definition>
        <argsstring>(const T &amp;other) const noexcept</argsstring>
        <name>operator==</name>
        <qualifiedname>TOptRef::operator==</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="372" column="6" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="372" bodyend="375"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1ab60b25e46d385b02597a50b5873a3f24" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool TOptRef&lt; T &gt;::operator==</definition>
        <argsstring>(T &amp;&amp;other) const noexcept</argsstring>
        <name>operator==</name>
        <qualifiedname>TOptRef::operator==</qualifiedname>
        <param>
          <type>T &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="377" column="6" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="377" bodyend="380"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1add4f00456f9a7c58db23099b69e0b157" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename _Other</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_assignable_v&lt; T, _Other &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>bool</type>
        <definition>bool TOptRef&lt; T &gt;::operator!=</definition>
        <argsstring>(TOptRef&lt; _Other &gt; other) const noexcept</argsstring>
        <name>operator!=</name>
        <qualifiedname>TOptRef::operator!=</qualifiedname>
        <param>
          <type><ref refid="class_t_opt_ref" kindref="compound">TOptRef</ref>&lt; _Other &gt;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="383" column="6" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="383" bodyend="386"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1acfcb205fe5e9abf3bcea379679970a56" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool TOptRef&lt; T &gt;::operator!=</definition>
        <argsstring>(const T &amp;other) const noexcept</argsstring>
        <name>operator!=</name>
        <qualifiedname>TOptRef::operator!=</qualifiedname>
        <param>
          <type>const T &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="388" column="6" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="388" bodyend="391"/>
      </memberdef>
      <memberdef kind="function" id="class_t_opt_ref_1a81b729da9f5a72fcfa7f1cdb09074d0a" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool TOptRef&lt; T &gt;::operator!=</definition>
        <argsstring>(T &amp;&amp;other) const noexcept</argsstring>
        <name>operator!=</name>
        <qualifiedname>TOptRef::operator!=</qualifiedname>
        <param>
          <type>T &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="393" column="6" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="393" bodyend="396"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>A nullable reference, but explicitly stated.</para>
<para>Contains functions to act on the resulting value.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type this reference points to. May be const. Untested when T is a reference itself. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
    </detaileddescription>
    <location file="Source/DONToUnreal/Public/Util/Types/TOptRef.h" line="18" column="1" bodyfile="Source/DONToUnreal/Public/Util/Types/TOptRef.h" bodystart="20" bodyend="400"/>
    <listofallmembers>
      <member refid="class_t_opt_ref_1a4fbb624882f1c14c3af0e9e43bbcce79" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>Filter</name></member>
      <member refid="class_t_opt_ref_1ab5d28c77bb4de4208ce243cf16bae19a" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>FlatMapOwned</name></member>
      <member refid="class_t_opt_ref_1adf1099e338972547da0563ee5351740d" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>FlatMapRef</name></member>
      <member refid="class_t_opt_ref_1a05a83aa61596f23adb68527a3a1658ab" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>GetOrCompute</name></member>
      <member refid="class_t_opt_ref_1a4957f2b787751731a9fdc91c07efa495" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>GetOrDefault</name></member>
      <member refid="class_t_opt_ref_1af4201f958c1d1e94dc7a66fd24187654" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>GetOrThrow</name></member>
      <member refid="class_t_opt_ref_1ae7397f4e9d7068bf1c30b87cd5ccbccf" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>GetOrThrow</name></member>
      <member refid="class_t_opt_ref_1a5f951fd9dbff9807f950b4ff89877590" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>GetOrThrow</name></member>
      <member refid="class_t_opt_ref_1a27cd73704eb5ea88b4eec8a94c5d3199" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>GetPtrOrNull</name></member>
      <member refid="class_t_opt_ref_1ac8cee5d28098ca4fdcf4356b0a9442c2" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>GetUnchecked</name></member>
      <member refid="class_t_opt_ref_1a1dae279b45fce7334dacee74d35327d6" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>IfAbsent</name></member>
      <member refid="class_t_opt_ref_1a7293eed17c4eb659701bb7f3136e09ce" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>IfPresent</name></member>
      <member refid="class_t_opt_ref_1a9b47ab26f114025b0fb381641f55861c" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>IsAbsent</name></member>
      <member refid="class_t_opt_ref_1a84ffb13c3920c51197e9c2349f822aa9" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>IsPresent</name></member>
      <member refid="class_t_opt_ref_1ac347e0a187b4f72ce6caa5408b6871a0" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>MapOwned</name></member>
      <member refid="class_t_opt_ref_1a9a861932ffbbd6377cde20b2aebe02e7" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>MapRef</name></member>
      <member refid="class_t_opt_ref_1a3dc743843189e9871240666825f3d966" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator bool</name></member>
      <member refid="class_t_opt_ref_1add4f00456f9a7c58db23099b69e0b157" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator!=</name></member>
      <member refid="class_t_opt_ref_1acfcb205fe5e9abf3bcea379679970a56" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator!=</name></member>
      <member refid="class_t_opt_ref_1a81b729da9f5a72fcfa7f1cdb09074d0a" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator!=</name></member>
      <member refid="class_t_opt_ref_1a1cec093d72cdeab5a61cbd4a001131c3" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator*</name></member>
      <member refid="class_t_opt_ref_1ae24825a8cf4a61cfcad11343b550fa5c" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator-&gt;</name></member>
      <member refid="class_t_opt_ref_1ad597e62d4cfeafe177727166961cbfd1" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator=</name></member>
      <member refid="class_t_opt_ref_1acaaac53a3ef39ec552657586474e614c" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator=</name></member>
      <member refid="class_t_opt_ref_1ac0e3a28440798946e9cbd78c490ffa69" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator==</name></member>
      <member refid="class_t_opt_ref_1ac0e3a28440798946e9cbd78c490ffa69" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator==</name></member>
      <member refid="class_t_opt_ref_1ab0042d7878115deabae1bea1c3044894" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator==</name></member>
      <member refid="class_t_opt_ref_1ab60b25e46d385b02597a50b5873a3f24" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>operator==</name></member>
      <member refid="class_t_opt_ref_1a32ed303aabc85e550ba58665a518837b" prot="private" virt="non-virtual"><scope>TOptRef</scope><name>ptr</name></member>
      <member refid="class_t_opt_ref_1a35dadcbc4587d3df3e059a707ea8e3c7" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>ToOwned</name></member>
      <member refid="class_t_opt_ref_1a13d0b9643067b6b855ba093234f336d6" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>ToOwned</name></member>
      <member refid="class_t_opt_ref_1a9ddaf93eda5e02d13024a0876b6dc0e8" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>ToOwnedOrCompute</name></member>
      <member refid="class_t_opt_ref_1aa56016a1dd44de0bd878672b2b29f4aa" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>TOptRef</name></member>
      <member refid="class_t_opt_ref_1a9679ebcbb8e591c63032f9ec3effb5d9" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>TOptRef</name></member>
      <member refid="class_t_opt_ref_1a0f74b71b5917a4c5e6bafcc95ef208d8" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>TOptRef</name></member>
      <member refid="class_t_opt_ref_1a156a170db9f169f01325ac3c6624e570" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>TOptRef</name></member>
      <member refid="class_t_opt_ref_1a24c011fa67975cab3524f60e3b9f7389" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>TOptRef</name></member>
      <member refid="class_t_opt_ref_1acd0ea3210a6422cfd8c3832e6fc8a85c" prot="public" virt="non-virtual"><scope>TOptRef</scope><name>TOptRef</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
